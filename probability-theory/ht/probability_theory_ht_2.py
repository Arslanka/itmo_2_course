# -*- coding: utf-8 -*-
"""Probability Theory HT 2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13wrZt83_elSTjWvzkPrcQe95kDuh_FRC

# Probability Theory HT2 (19.1, 19.2)
***Author***: *Giniiatullin Arslan Rafailovich*\
***Group***: *P32121*
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

"""##19.1"""

import scipy as scp
from scipy.interpolate import make_interp_spline
from scipy.stats import *

"""1. Write down the values as a series of variations."""

matrix = np.array([[9.4, 7.9, 0.3, 6.8, 4.2, 11.9, 7.8, 1.7, 5.1, 8.8],
          [8.7, 11.1, 7.7, 1.8, 5.5, 10.5, 4.3, 3.8, 1.4, 11.2],
          [1.1, 7.3, 3.7, 4.4, 11.8, 8.6, 1.9, 5.6, 10.1, 8.4],
          [10.0, 11.6, 5.2, 2.1, 5.7, 4.8, 7.4, 0.8, 4.7, 3.6],
          [8.3, 7.6, 0.7, 7.3, 3.4, 11.4, 5.7, 9.9, 2.2, 7.2],
          [2.3, 4.7, 9.7, 11.3, 5.8, 4.9, 3.3, 0.5, 7.5, 4.6],
          [5.0, 0.4, 8.9, 7.1, 9.6, 11.5, 5.9, 9.0, 5.3, 2.4],
          [9.5, 5.9, 1.0, 9.1, 2.5, 6.0, 8.2, 3.2, 10.9, 6.1],
          [10.2, 2.6, 4.5, 3.1, 6.2, 11.7, 6.3, 0.2, 7.0, 9.2],
          [1.2, 6.4, 11.9, 6.9, 8.1, 6.5, 2.9, 6.2, 4.4, 10.3]])
matrix = sorted(matrix.flatten())
matrix = np.reshape(matrix, (10, 10)) #variation series
print(matrix)

"""2. Find the scope of variation and divide it into ***number_of_intervals*** (9)  intervals."""

number_of_intervals = 9

x_min = np.min(matrix)
x_max = np.max(matrix)
scope = (np.max(matrix) - np.min(matrix)) #variation scope
h = scope / number_of_intervals
columns = ['x_i-x_i+1', 'x_i`', 'n_i', 'W_i', 'W_i/h']
df = pd.DataFrame(index=range(number_of_intervals), columns=columns)
x_df = x_min
for index in range (0, number_of_intervals): 
  df.at[index, 'x_i-x_i+1'] = "{}-{}".format(x_df, (x_df + h))
  df.at[index, 'x_i`'] = (x_df + x_df + h) / 2
  df.at[index, 'n_i'] = ((x_df <= matrix) & (matrix <= (x_df + h))).sum()
  df.at[index, 'W_i'] = df.at[index, 'n_i'] / matrix.size
  df.at[index, 'W_i/h'] = df.at[index, 'W_i'] / h
  x_df += h

df

"""3. Construct a frequency polygon, a histogram of relative frequencies, and a graph of the empirical distribution function."""

f = pd.DataFrame(index=range(number_of_intervals), columns=['X', 'X`', 'N', 'W', 'F*(X)'])
x_df = x_min

f.at[0, 'X'] = x_df
f.at[0, 'X`'] = (x_df+ x_df + h) / 2
f.at[0, 'N'] = df.at[0, 'n_i']
f.at[0, 'W'] = df.at[0, 'W_i/h']
f.at[0, 'F*(X)'] = 0

for index in range(1, number_of_intervals):
  f.at[index, 'X'] = x_df + h
  f.at[index, 'X`'] = (f.at[index, 'X'] + f.at[index, 'X'] + h) / 2
  f.at[index, 'N'] = df.at[index, 'n_i']
  f.at[index, 'W'] = df.at[index, 'W_i/h']
  f.at[index, 'F*(X)'] = f.at[index - 1, 'F*(X)'] + df.at[index - 1, 'W_i']
  x_df += h

plt.xlabel("x_i")
plt.ylabel("n_i")
plt.grid(True, color = "black", linewidth = "1.4", linestyle = "-")
plt.plot(f['X`'], f['N'], 'bo-')
plt.show() #frequency polygon

bar = pd.DataFrame(index=range(number_of_intervals * 2), columns=['X', 'W'])
bar.at[0, 'X'] = 0
bar.at[0, 'W'] = 0
for index in range(1, number_of_intervals*2, 2):
    bar.at[index, 'X'] = f.at[(index + 1) / 2 - 1, 'X']
    bar.at[index, 'W'] = bar.at[index - 1, 'W']
    bar.at[index + 1, 'X'] = f.at[(index + 1) / 2 - 1, 'X']
    bar.at[index + 1, 'W'] = f.at[(index + 1) / 2 - 1, 'W']

plt.xlabel("x_i")
plt.ylabel("w_i")
plt.grid(True, color = "black", linewidth = "1.4", linestyle = "-")
plt.plot(bar['X'], bar['W'], 'bo-')
plt.show() #hystogram of relative frequencies


ff = pd.DataFrame(index=range(number_of_intervals * 2), columns=['X', 'F*(X)'])
ff.at[0, 'X'] = 0
ff.at[0, 'F*(X)'] = 0
for index in range(1, number_of_intervals*2, 2):
    ff.at[index, 'X'] = f.at[(index + 1) / 2 - 1, 'X']
    ff.at[index, 'F*(X)'] = ff.at[index - 1, 'F*(X)']
    ff.at[index + 1, 'X'] = f.at[(index + 1) / 2 - 1, 'X']
    ff.at[index + 1, 'F*(X)'] = f.at[(index + 1) / 2 - 1, 'F*(X)']

plt.xlabel("x_i")
plt.ylabel("F*(x)")
plt.grid(True, color = "black", linewidth = "1.4", linestyle = "-")
plt.plot(ff['X'], ff['F*(X)'], 'bo-')
plt.show() #graph of the empirical distribution function

display(f)
display(bar)

"""4. Find numerical characteristics and choices 𝚬[𝐗], 𝐃[𝐗] """

ExDx = df[['x_i-x_i+1', 'x_i`', 'n_i']].copy()
ExDx['n_ix_i`'] = 0
ExDx['(x_i`)^2'] = 0
ExDx['n_i(x_i`)^2'] = 0
for index in range(0, number_of_intervals):  
    ExDx.at[index, 'n_ix_i`'] = ExDx.at[index, 'x_i`'] * ExDx.at[index, 'n_i']
    ExDx.at[index, '(x_i`)^2'] = ExDx.at[index, 'x_i`']**2
    ExDx.at[index, 'n_i(x_i`)^2'] = ExDx.at[index, 'n_i'] * ExDx.at[index, '(x_i`)^2']

Ex = ExDx['n_ix_i`'].sum() / matrix.size #calculate expected value
Dx = (ExDx['n_i(x_i`)^2'].sum() / matrix.size) - Ex**2 #calculate dispersion
QD = Dx**(0.5)
Dx_v =(matrix.size / (matrix.size - 1)) * Dx
QD_v = Dx_v**(0.5)
print('Ex={}'.format(Ex))
print('Dx={}'.format(Dx))
print('QD={}'.format(QD))


print('Dx_v={}'.format(Dx_v))
print('QD_v={}'.format(QD_v))

ExDx

"""5. Taking the hypothesis $𝐻_0$ as null: the general population from which the sample is extracted has a normal distribution, check it using the Pearson criterion at the significance level α = 0.025 ;"""

alpha = 0.025

interval_left = x_min
interval_right = x_min + h
cur_frequency = 0
Zt = pd.DataFrame()
for index in range(0, number_of_intervals):
  cur_frequency += df.at[index, 'n_i']
  if cur_frequency >= 5: #According to Pearson's criterion, the frequency should be >= 5
    Zt.at[index, 'x_i'] = interval_left
    Zt.at[index, 'x_i+1'] = interval_right
    Zt.at[index, 'x_i-[x]'] = Zt.at[index, 'x_i'] - Ex
    Zt.at[index, 'x_i+1-[x]'] = Zt.at[index, 'x_i+1'] - Ex
    Zt.at[index, 'z_i'] = Zt.at[index, 'x_i-[x]'] / QD
    Zt.at[index, 'z_i+1'] = Zt.at[index, 'x_i+1-[x]'] / QD
    Zt.at[index, 'n_i'] = cur_frequency
    interval_left = interval_right
    cur_frequency = 0
  interval_right = interval_right + h 

if Zt.empty == False:
  Zt.at[0, 'x_i-[x]'] = float('-inf')
  Zt.at[0, 'z_i'] = float('-inf')
  Zt.at[Zt.shape[0] - 1, 'x_i+1-[x]'] = float('+inf')
  Zt.at[Zt.shape[0] - 1, 'z_i+1'] = float('+inf')


Pt=Zt[['z_i', 'z_i+1']].copy()
for index in range (0, Pt.shape[0]):
  if Pt.at[index, 'z_i'] == float('-inf'):
    Pt.at[index, 'Ф(z_i)'] = -0.5
  else: Pt.at[index, 'Ф(z_i)'] = scp.stats.norm.cdf(Pt.at[index, 'z_i']) - 0.5

  if Pt.at[index, 'z_i+1'] == float('+inf'):
    Pt.at[index, 'Ф(z_i+1)'] = 0.5
  else: Pt.at[index, 'Ф(z_i+1)'] = scp.stats.norm.cdf(Pt.at[index, 'z_i+1']) - 0.5

  Pt.at[index, 'P_i'] = Pt.at[index, 'Ф(z_i+1)'] -Pt.at[index, 'Ф(z_i)']
  Pt.at[index, 'n_i`'] = 100*Pt.at[index, 'P_i']

Ht=pd.DataFrame()

for index in range(0, Pt.shape[0]):
  Ht.at[index, 'n_i'] = Zt.at[index, 'n_i']
  Ht.at[index, 'n_i`'] = Pt.at[index, 'n_i`']
  Ht.at[index, 'n_i-n_i`'] = Ht.at[index, 'n_i'] - Ht.at[index, 'n_i`']
  Ht.at[index, '(n_i-n_i`)^2'] = Ht.at[index, 'n_i-n_i`']**2
  Ht.at[index, '(n_i-n_i`)^2 / (n_i`)'] = Ht.at[index, '(n_i-n_i`)^2'] / Ht.at[index, 'n_i`']
  Ht.at[index, '(n_i)^2'] = Ht.at[index, 'n_i']**2
  Ht.at[index, '(n_i)^2 / n_i`'] = Ht.at[index, '(n_i)^2'] / Ht.at[index, 'n_i`']


control_sum = Ht['(n_i-n_i`)^2 / (n_i`)'].sum()
print("control sum is {}".format(control_sum))

k = Ht.shape[0] - 3 #degree of freedom
print("degree of freedom k is {}".format(k))

x2k= 14.4 #find in table 10. for me it's 14.4 (alpha=0.025, k=6)
print("x^2_кр for alpha={} and degree of freedom={} is {}".format(alpha, k, x2k))

if control_sum < x2k:
  print('H0 hypothesis is correct')
else:
  print('H0 hypothesis is incorrect')

display(Zt)
display(Pt)
display(Ht)

"""6. Find confidence intervals for the mathematical expectation and the mean square deviation with the reliability of γ = 0.9."""

y=(0.9 + 1) / 2
t_y = 1.645
sigma = (QD_v / ((matrix.size)**(0.5))) * t_y
alpha_left = Ex - sigma
alpha_right = Ex + sigma
print('confidence interval for alpha is ({}, {})\n'.format(alpha_left, alpha_right))

q=0.135
sigma_left = QD_v * (1 - q)
sigma_right = QD_v * (1 + q)

print('confidence interval for sigma is ({}, {})\n'.format(sigma_left, sigma_right))

"""##19.2

A table of the distribution of 100 plants by means of production X (thousand den. units) and by exact production Y (t) is given. It is known that there is a linear correlation between X and Y. Required:

a) find the equation of direct regression y on x;
"""

df = pd.DataFrame({'X': [0.9, 1.05, 1.20, 1.35, 1.5, 1.65, 0, 0],
                   'Y': [21.0, 21.3, 21.6, 21.9, 22.2, 22.5, 22.8, 23.1],
                   'm_x': [6, 9, 18, 29, 20, 18, 0,],
                   'm_y': [1, 7, 9, 16, 27, 21, 4, 5],
                  'values': [0, 0, 0, 0, 0, 0, 0, 0]
                  })
df.pivot(index=['X', 'm_x'], columns=['Y', 'm_y'], values='values')

"""b) construct the equation of the empirical regression line and
random sampling points (X, Y).
"""